#pragma once

#include "Interfaces.h"

#include <atomic>

namespace StepperControl {
template <int i>
struct StepperNumber {
    static const int value = i;
};

// Starts timer and generates steps using provided linear or parabolic trajectory.
// Uses modified Bresenham's line drawing algorithm.
template <typename TMotor, typename TTicker, typename AxesTraits = DefaultAxesTraits>
class SegmentsExecutor {
  public:
    static const int size = AxesTraits::size;
    using Ai = TAi<size>;
    using Sg = TSg<size>;
    using Sgs = TSgs<size>;
    using Callback = void (*)(void *);

    SegmentsExecutor(TMotor *motor, TTicker *ticker)
        : running_(false), motor_(motor), ticker_(ticker), position_(axZero<Ai>()),
          ticksPerSecond_(1), onStarted_(nullptr, nullptr), onStopped_(nullptr, nullptr) {
        scAssert(motor_ && ticker_);
        it_ = trajectory_.data() + trajectory_.size();
    }

    int32_t ticksPerSecond() const { return ticksPerSecond_; }

    void setTicksPerSecond(int32_t ticksPerSecond) {
        scAssert(ticksPerSecond > 0);
        ticksPerSecond_ = ticksPerSecond;
    }

    void setTrajectory(Sgs const &segments) {
        trajectory_ = segments;
        it_ = trajectory_.data() + trajectory_.size();
    }

    void setTrajectory(Sgs &&segments) {
        trajectory_ = move(segments);
        it_ = trajectory_.data() + trajectory_.size();
    }

    Sgs const &segments() const { return trajectory_; }

    void setOnStarted(Callback func, void *payload) { onStarted_ = std::make_pair(func, payload); }

    void setOnStopped(Callback func, void *payload) { onStopped_ = std::make_pair(func, payload); }

    void start() {
        if (trajectory_.empty()) {
            return;
        }
        it_ = trajectory_.data();
        running_ = true;
        currentTick_ = 0;
        if (onStarted_.first) {
            onStarted_.first(onStarted_.second);
        }

        ticker_->attach_us(this, &SegmentsExecutor::tick, 1000000 / ticksPerSecond_);
    }

    void tick() {
        auto const dt = it_->dt;
        if (dt > 0) {
            // Integrate next interval.
            tick0();
        } else if (dt == 0 && ++it_ != (trajectory_.data() + trajectory_.size())) {
            // If there is next segment then integrate it's first interval.
            tick0();
        } else if (dt < 0) {
            // It is a homing cycle.
            if (any(neq(it_->velocity, 0))) { // all velocities != 0 -- still homing
                // If any of switches is not hit then integrate next interval.
                tick0();

                // Check end switch for every axis and stop if hit.
                for (int i = 0; i < AxesTraits::size; i++) {
                    if (it_->velocity[i] != 0 && motor_->checkEndSwitchHit(i)) {
                        it_->velocity[i] = 0;
                    }
                }
            } else {
                // Stop and reset position when all switches are hit.
                it_->dt = 0;
                position_.fill(0);
            }
        } else {
            // No trajectory left.
            stop();
        }
    }

    bool isRunning() const { return running_; }

    int32_t currentTick() const { return currentTick_; }

    void stop() {
        ticker_->detach();
        it_ = trajectory_.data() + trajectory_.size();
        running_ = false;
        currentTick_ = 0;
        if (onStopped_.first) {
            onStopped_.first(onStopped_.second);
        }
    }

    Ai const &position() const { return position_; }

    void setPosition(Ai const &position = axZero<Ai>()) { position_ = position; }

  private:
    FORCE_INLINE void tick0() {
        motor_->begin();

        // Update time.
        --it_->dt;
        ++currentTick_;

        anyStep_ = false;
        anyDir_ = false;

        for (int i = 0; i < size; ++i) {
            auto oldDir = dir_[i];
            dir_[i] = it_->velocity[i] < 0;
            if (oldDir != dir_[i]) {
                anyDir_ = true;
            }
        }

        if (anyDir_) {
            updateDir(StepperNumber<0>{});
            wait_us(2);
        }

        // Dir and step writing are separated by error updates to provide delay between them.
        updateErr(StepperNumber<0>{});

        if (anyStep_) {
            updateStep(StepperNumber<0>{});
            wait_us(2);
            clearStep(StepperNumber<0>{});
        }

        // Notify motor about integration end.
        motor_->end();
    }

    template <int i>
    FORCE_INLINE void updateErr(StepperNumber<i>) {
        // Update difference between rounded and actual position.
        it_->error[i] += it_->velocity[i];

        int sign = it_->velocity[i] >= 0 ? 1 : -1;

        // +1 -- positive or zero slope; -1 -- negative slope.
        //       error >= 0.5                  error <= -0.5
        if (2 * sign * it_->error[i] >= it_->denominator) {
            //   error -= 1                    error += 1
            it_->error[i] -= it_->denominator * sign;
            // Rising edge.
            position_[i] += sign;

            step_[i] = true;
            anyStep_ = true;
        } else {
            step_[i] = false;
        }

        it_->velocity[i] += it_->acceleration[i];

        updateErr(StepperNumber<i + 1>{});
    }

    FORCE_INLINE void updateErr(StepperNumber<size>) {}

    // Integrate i-th axis.
    template <int i>
    FORCE_INLINE void updateDir(StepperNumber<i>) {
        motor_->writeDirection(StepperNumber<i>{}, dir_[i]);

        updateDir(StepperNumber<i + 1>{});
    }

    // All axes were integrated.
    FORCE_INLINE void updateDir(StepperNumber<size>) {}

    template <int i>
    FORCE_INLINE void updateStep(StepperNumber<i>) {
        motor_->writeStep(StepperNumber<i>{}, step_[i]);

        updateStep(StepperNumber<i + 1>{});
    }

    FORCE_INLINE void updateStep(StepperNumber<size>) {}

    template <int i>
    FORCE_INLINE void clearStep(StepperNumber<i>) {
        motor_->writeStep(StepperNumber<i>{}, false);

        clearStep(StepperNumber<i + 1>{});
    }

    FORCE_INLINE void clearStep(StepperNumber<size>) {}

    std::atomic<int32_t> currentTick_{};

    bool anyStep_{};
    bool anyDir_{};
    bool step_[size]{};
    bool dir_[size]{};

    std::atomic<bool> running_{false};
    Sg *RESTRICT it_;
    Sgs trajectory_;
    TMotor *motor_;
    TTicker *ticker_;
    Ai position_;
    int32_t ticksPerSecond_;
    std::pair<Callback, void *> onStarted_;
    std::pair<Callback, void *> onStopped_;
};
}
